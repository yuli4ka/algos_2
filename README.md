# algos_2# algos_2 task_7
Біноміальне дерево - дерево, що задається рекурентно. B0 - це просто вершина. Ві - це Ві-1, лівим сином якого зробили Ві-1.
Властивості біноміальних дерев:
1) 2^k вершин
2) Висота дерева рівна k
3) С з і по k (біноміальний коефіцієнт) - кількість вершин глибини і
4) діти Ві - це Ві-1, Ві-2, ... ,В0
5) Максимальна висота вершини дерева Вn рівна O(log N)

Біноміальна куча - це множина біноміальних дерев з певними властивостями: 1)У кожному біноміальному дереві зберігається властивість кучі; Нема двух дерев однакового розміру; Дерева впорядковані за розміром; Біноміальне дерево - це дерево, яке задається рекурентно, біноміальне дерево із степенем i має і-1 синів, лівий син - це біноміальне дерево із степенем і-1, правий син - біноміальне дерево із степенем 1. Біноміальне дерево з індексом 1 - це просто вершина. Біноміальна піраміда - це множина біноміальних дерев з певними властивостями:

У кожному біноміальному дереві зберігається властивість піраміди.
Немає жодних двох дерев однакового розміру
Дерева впорядковані по розміру.
У біноміального дерева є ряд цікавих властивостей: T.1. 2k вершин T.2. Висота дерева k T.3. Сi k вершин глибини i (Ci k - биномиальный коэффициент). T.4. Максимальна висота вершини у биноміальному дереві O(log N)

Властивість біноміальної кучі: Н.1. Кількість дерев = O(log N), де N - кількість елементів у кучі.

Реалізовані операції:

Merge. Задача: об'єднати 2 кучі в одну. Алгоритм: объеднаємо кореневі списки куч в один список, підтримуючи впорядкованість за pow. Алгоритм аналогічний злиттю в mergeSort: Зберігаємо по вказівнику на початки списків і в результуючий список записуємо мінімальный з них, той з якого щойно записали зміщуємо на наступний єлемент. Далі проходимо від початку до кінця нового отриманого списку коренів і зливаємо дерева однакового розміру. Можуть бути випадки:

Тільки 2 дерева однакового разміру. Тоді об'єднуємо їх.
3 дерева однакового разміру. Об'єднуємо 2 останніх. При об'єднанні двох дерев потрібно подивитись, в корні якого з них менший ключ і зробити інше дерево лівим сином кореня цього дерева. Складність: Час роботи O(root_list1.length) + O(root_list2.length) = O(log N). За один прохід (O(log N )) ми отримаємо об'єднане біноміальне дерево. Тоді загальна складність O(log N).
Insert Задача: додати новий елемент в кучу. Алгоритм: Створюємо кучу з одного елемента і об'єднуємо с необхідною кучею. Складність: O(1) + O(log(N)) = O(log(N)).

GetMinimum Задача: знайти мінімум в кучі. Алгоритм: очевидно, що минимум знаходиться в списку коренів, тобто щоб його знайти потрібно пройтись по списку коренів. Складність: O(root_list.length) = O(log(N)).

ExtractMin Задача: видалити минимальный элемент. Алгоритм: знаходимо його за допомогою Minimum. Видаляємо його його списку коренів. З перевернутого списку його дітей робимо root_list для нової кучі (H1) і об'єднуємо початкову кучу с H1. Складність: так як кожна операція працює за O(log N): O(log N) + O(log N) + O(log N) = O(log N)

DecreaseKey Задача: зменшити значення data в даній вершині. Алгоритм: зменшуємо значення в вершині. Тоді якщо властивість піраміди буде порушена для цієї вершини і її предка, міняємо їх місцями. Провжуємо процес, поки вершина не стане на необхідне місце. Аналогічно бінарним пірамідам. Складність: В найгіршому випадку наша вершина буде вспливати до кореня від листя, тобто ми зробимо O(log N ) операцій (висота біноміального дерева за T.4 O(log N))
