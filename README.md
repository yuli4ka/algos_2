# algos_2# algos_2 task_7
Біноміальне дерево - дерево, що задається рекурентно. B0 - це просто вершина. Ві - це Ві-1, лівим сином якого зробили Ві-1.
Властивості біноміальних дерев:
1) 2^k вершин
2) Висота дерева рівна k
3) С з і по k (біноміальний коефіцієнт) - кількість вершин глибини і
4) діти Ві - це Ві-1, Ві-2, ... ,В0
5) Максимальна висота вершини дерева Вn рівна O(log N)

Біноміальна куча - це множина біноміальних дерев з певними властивостями: 
1)У кожному біноміальному дереві зберігається властивість кучі; 
2)Нема двох дерев однакового розміру; 
3)Дерева впорядковані за розміром; 

Зберігаємо дерево таким чином:ключ вершини,кількість її синів, правий брат та лівий син.

Реалізовані операції:

Merge. Задача: об'єднати 2 кучі в одну. Алгоритм: объеднаємо кореневі списки куч в один список, підтримуючи впорядкованість за pow. Алгоритм аналогічний злиттю в mergeSort: Зберігаємо по вказівнику на початки списків і в результуючий список записуємо мінімальный з них, той з якого щойно записали зміщуємо на наступний єлемент. Далі проходимо від початку до кінця нового отриманого списку коренів і зливаємо дерева однакового розміру. Можуть бути випадки:

Тільки 2 дерева однакового разміру. Тоді об'єднуємо їх.
3 дерева однакового разміру. Об'єднуємо 2 останніх. При об'єднанні двох дерев потрібно подивитись, в корні якого з них менший ключ і зробити інше дерево лівим сином кореня цього дерева. Складність: Час роботи O(root_list1.length) + O(root_list2.length) = O(log N). За один прохід (O(log N )) ми отримаємо об'єднане біноміальне дерево. Тоді загальна складність O(log N).
Insert Задача: додати новий елемент в кучу. Алгоритм: Створюємо кучу з одного елемента і об'єднуємо с необхідною кучею. Складність: O(1) + O(log(N)) = O(log(N)).

GetMinimum Задача: знайти мінімум в кучі. Алгоритм: очевидно, що минимум знаходиться в списку коренів, тобто щоб його знайти потрібно пройтись по списку коренів. Складність: O(root_list.length) = O(log(N)).

ExtractMin Задача: видалити минимальный элемент. Алгоритм: знаходимо його за допомогою Minimum. Видаляємо його його списку коренів. З перевернутого списку його дітей робимо root_list для нової кучі (H1) і об'єднуємо початкову кучу с H1. Складність: так як кожна операція працює за O(log N): O(log N) + O(log N) + O(log N) = O(log N)

DecreaseKey Задача: зменшити значення data в даній вершині. Алгоритм: зменшуємо значення в вершині. Тоді якщо властивість піраміди буде порушена для цієї вершини і її предка, міняємо їх місцями. Провжуємо процес, поки вершина не стане на необхідне місце. Аналогічно бінарним пірамідам. Складність: В найгіршому випадку наша вершина буде вспливати до кореня від листя, тобто ми зробимо O(log N ) операцій (висота біноміального дерева за T.4 O(log N))
